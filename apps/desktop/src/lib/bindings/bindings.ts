// This file has been generated by Specta. DO NOT EDIT.

import { createTauRPCProxy as createProxy, type InferCommandOutput } from 'taurpc'
type TAURI_CHANNEL<T> = (response: T) => void


/**
 * An AI message in the conversation.
 */
export type AIMessage = { 
/**
 * The message content
 */
content: string; 
/**
 * Optional unique identifier
 */
id: string | null; 
/**
 * Tool calls made by the AI
 */
tool_calls?: ToolCall[]; 
/**
 * Additional metadata
 */
additional_kwargs?: Partial<{ [key in string]: JsonValue }> }

export type AppSettings = { 
/**
 * General settings
 */
general: GeneralSettings; 
/**
 * Telemetry settings
 */
telemetry: TelemetrySettings; 
/**
 * Backend provider settings
 */
backend?: BackendSettings }

export type BackendSettings = { backendType: BackendType }

export type BackendType = "None" | "Ollama" | "Eurora" | "OpenAI" | "Anthropic"

/**
 * A unified message type that can represent any message role.
 */
export type BaseMessage = 
/**
 * A human message
 */
({ type: "Human" } & HumanMessage) | 
/**
 * A system message
 */
({ type: "System" } & SystemMessage) | 
/**
 * An AI message
 */
({ type: "AI" } & AIMessage) | 
/**
 * A tool result message
 */
({ type: "Tool" } & ToolMessage)

/**
 * A content part in a multimodal message.
 * 
 * Messages can contain multiple content parts, allowing for mixed text and images.
 */
export type ContentPart = 
/**
 * Text content.
 */
{ type: "text"; text: string } | 
/**
 * Image content.
 */
{ type: "image"; source: ImageSource; detail?: ImageDetail | null }

/**
 * Context chip for UI integration
 */
export type ContextChip = { id: string; extension_id: string; name: string; attrs: Partial<{ [key in string]: string }>; icon: string | null; position: number | null }

export type Conversation = { id: string; title: string | null; created_at: string; updated_at: string }

export type GeneralSettings = { 
/**
 * Whether to start the app on autostart
 */
autostart: boolean }

/**
 * A human message in the conversation.
 * 
 * Human messages support both simple text content and multimodal content
 * with images. Use [`HumanMessage::new`] for simple text messages and
 * [`HumanMessage::with_content`] for multimodal messages.
 */
export type HumanMessage = { 
/**
 * The message content (text or multipart)
 */
content: MessageContent; 
/**
 * Optional unique identifier
 */
id: string | null; 
/**
 * Additional metadata
 */
additional_kwargs?: Partial<{ [key in string]: JsonValue }> }

/**
 * Image detail level for vision models.
 * 
 * This controls how the model processes the image:
 * - `Low`: Faster, lower token cost, suitable for simple images
 * - `High`: More detailed analysis, higher token cost
 * - `Auto`: Let the model decide based on image size
 */
export type ImageDetail = "low" | "high" | "auto"

/**
 * Source of an image for multimodal messages.
 */
export type ImageSource = 
/**
 * Image from a URL.
 */
{ type: "url"; url: string } | 
/**
 * Base64-encoded image data.
 */
{ type: "base_64"; media_type: string; data: string }

export type JsonValue = null | boolean | number | string | JsonValue[] | Partial<{ [key in string]: JsonValue }>

export type LoginToken = { code_challenge: string; expires_in: bigint; url: string }

/**
 * Message content that can be either simple text or multipart.
 */
export type MessageContent = 
/**
 * Simple text content.
 */
string | 
/**
 * Multiple content parts (for multimodal messages).
 */
ContentPart[]

export type Query = { text: string; assets: string[] }

export type ResponseChunk = { chunk: string }

/**
 * A system message in the conversation.
 */
export type SystemMessage = { 
/**
 * The message content
 */
content: string; 
/**
 * Optional unique identifier
 */
id: string | null; 
/**
 * Additional metadata
 */
additional_kwargs?: Partial<{ [key in string]: JsonValue }> }

export type TelemetrySettings = { 
/**
 * Anonymous metrics
 */
anonymousMetrics: boolean; 
/**
 * Anonymous error reporting
 */
anonymousErrors: boolean; 
/**
 * Non-anonymous metrics
 */
nonAnonymousMetrics: boolean; 
/**
 * Distinct ID, if non-anonymous metrics are enabled
 */
distinctId: string | null }

export type TimelineAppEvent = { name: string; color: string | null; icon_base64: string | null }

/**
 * A tool call made by the AI model.
 */
export type ToolCall = { 
/**
 * Unique identifier for this tool call
 */
id: string; 
/**
 * Name of the tool to call
 */
name: string; 
/**
 * Arguments for the tool call as a JSON object
 */
args: JsonValue }

/**
 * A tool message containing the result of a tool call.
 */
export type ToolMessage = { 
/**
 * The tool result content
 */
content: string; 
/**
 * The ID of the tool call this message is responding to
 */
tool_call_id: string; 
/**
 * Optional unique identifier
 */
id: string | null; 
/**
 * Additional metadata
 */
additional_kwargs?: Partial<{ [key in string]: JsonValue }> }

const ARGS_MAP = { 'auth':'{"get_login_token":[],"poll_for_login":[]}', 'chat':'{"current_conversation_changed":["conversation"],"send_query":["conversation","channel","query"],"switch_conversation":["conversation_id"]}', 'context_chip':'{"get":[]}', 'monitor':'{"capture_monitor":["monitor_id"]}', 'onboarding':'{"get_browser_extension_download_url":[]}', 'personal_db.conversation':'{"create":[],"get_messages":["conversation_id"],"list":["limit","offset"],"new_conversation_added":["conversation"]}', 'personal_db.message':'{"get":["conversation_id","limit","offset"]}', 'prompt':'{"disconnect":[],"get_service_name":[],"prompt_service_change":["service_name"],"switch_to_ollama":["base_url","model"],"switch_to_remote":["provider","api_key","model"]}', 'settings':'{"get_all_settings":[],"get_general_settings":[],"get_telemetry_settings":[],"set_general_settings":["general_settings"]}', 'system':'{"check_grpc_server_connection":["server_address"],"list_activities":[]}', 'third_party':'{"check_api_key_exists":[],"save_api_key":["api_key"]}', 'timeline':'{"list":[],"new_app_event":["event"],"new_assets_event":["chips"]}' }
export type Router = { "auth": {get_login_token: () => Promise<LoginToken>, 
poll_for_login: () => Promise<boolean>},
"chat": {current_conversation_changed: (conversation: Conversation) => Promise<void>, 
send_query: (conversation: Conversation, channel: TAURI_CHANNEL<ResponseChunk>, query: Query) => Promise<string>, 
switch_conversation: (conversationId: string) => Promise<Conversation>},
"context_chip": {get: () => Promise<ContextChip[]>},
"monitor": {capture_monitor: (monitorId: string) => Promise<string>},
"onboarding": {get_browser_extension_download_url: () => Promise<string>},
"personal_db.conversation": {create: () => Promise<Conversation>, 
get_messages: (conversationId: string) => Promise<BaseMessage[]>, 
list: (limit: number, offset: number) => Promise<Conversation[]>, 
new_conversation_added: (conversation: Conversation) => Promise<void>},
"personal_db.message": {get: (conversationId: string, limit: number | null, offset: number | null) => Promise<BaseMessage[]>},
"prompt": {disconnect: () => Promise<null>, 
get_service_name: () => Promise<string>, 
prompt_service_change: (serviceName: string | null) => Promise<void>, 
switch_to_ollama: (baseUrl: string, model: string) => Promise<null>, 
switch_to_remote: (provider: string, apiKey: string, model: string) => Promise<null>},
"settings": {get_all_settings: () => Promise<AppSettings>, 
get_general_settings: () => Promise<GeneralSettings>, 
get_telemetry_settings: () => Promise<TelemetrySettings>, 
set_general_settings: (generalSettings: GeneralSettings) => Promise<null>},
"system": {check_grpc_server_connection: (serverAddress: string | null) => Promise<string>, 
list_activities: () => Promise<ContextChip[]>},
"third_party": {check_api_key_exists: () => Promise<boolean>, 
save_api_key: (apiKey: string) => Promise<null>},
"timeline": {list: () => Promise<string[]>, 
new_app_event: (event: TimelineAppEvent) => Promise<void>, 
new_assets_event: (chips: ContextChip[]) => Promise<void>} };


export const createTauRPCProxy = () => createProxy<Router>(ARGS_MAP)
export type { InferCommandOutput }
